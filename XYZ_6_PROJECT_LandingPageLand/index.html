<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paisaje Generativo Vivo</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: sans-serif; }
    canvas { display: block; }
    header {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0,0,0,0.3);
      z-index: 10;
    }
    nav a {
      color: #fff;
      margin: 0 10px;
      text-decoration: none;
      font-weight: bold;
    }
    nav a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <header>
    <div class="logo" style="color: #fff; font-size:1.2rem;">EcoArte</div>
    <nav>
      <a href="#home">Inicio</a>
      <a href="#features">Caracter√≠sticas</a>
      <a href="#contact">Contacto</a>
    </nav>
  </header>
  <canvas id="scene"></canvas>

  <script>
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function rand(min, max) { return Math.random() * (max - min) + min; }

    class Noise {
      constructor() { this.p = []; for (let i=0;i<512;i++) this.p[i]=Math.floor(Math.random()*256); }
      fade(t){return t*t*t*(t*(t*6-15)+10);}      lerp(t,a,b){return a+t*(b-a);}      grad(hash,x){return (hash&1)?-x:x;}
      get(x){ let xi=Math.floor(x)&255, xf=x-Math.floor(x), u=this.fade(xf);
        let a=this.p[xi], b=this.p[xi+1];
        return this.lerp(u,this.grad(a,xf),this.grad(b,xf-1))*2;
      }
    }
    const noise = new Noise();

    // Weather states
    const weatherStates = ['sunny','cloudy','rainy'];
    let weatherIndex = 0;
    setInterval(() => { weatherIndex = (weatherIndex+1) % weatherStates.length; }, 30000);

    // Draw functions
    function drawSky(t) {
      const state = weatherStates[weatherIndex];
      const a = (Math.sin(t*0.0005)+1)/2;
      const grd = ctx.createLinearGradient(0,0,0,H);
      let top, bottom;
      if (state==='sunny') {
        top = `rgba(${135+50*a|0},${206-50*a|0},${235},1)`;
        bottom = `rgba(${220},${246},${255},1)`;
      } else if (state==='cloudy') {
        top = `rgba(200,200,200,1)`;
        bottom = `rgba(150,150,150,1)`;
      } else {
        top = `rgba(80,80,100,1)`;
        bottom = `rgba(40,40,60,1)`;
      }
      grd.addColorStop(0, top);
      grd.addColorStop(1, bottom);
      ctx.fillStyle = grd;
      ctx.fillRect(0,0,W,H);
    }

    function drawHills(t) {
      for (let layer=0; layer<3; layer++) {
        ctx.beginPath();
        const y0 = H*(0.6 + layer*0.1);
        ctx.moveTo(0,H);
        for (let x=0; x<=W; x+=20) {
          const y = y0 + noise.get(x*0.005 + t*0.0002 + layer*15)*60;
          ctx.lineTo(x,y);
        }
        ctx.lineTo(W,H);
        ctx.closePath();
        const g = 30 + layer*30;
        ctx.fillStyle = `rgba(20,${g},20,${0.5 - layer*0.1})`;
        ctx.fill();
      }
    }

    function drawTree(x,y,len,ang,dep) {
      if (!dep) return;
      const x2 = x + Math.cos(ang)*len;
      const y2 = y + Math.sin(ang)*len;
      ctx.strokeStyle = `rgb(${50+dep*20},${30+dep*10},20)`;
      ctx.lineWidth = dep;
      ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();
      const sway = Math.sin(Date.now()*0.001 + dep)*0.05;
      drawTree(x2,y2,len*0.7,ang-0.5+sway,dep-1);
      drawTree(x2,y2,len*0.7,ang+0.5+sway,dep-1);
      if (dep<3) {
        ctx.fillStyle='rgba(34,139,34,0.6)'; ctx.beginPath();
        ctx.arc(x2,y2,dep*3,0,2*Math.PI); ctx.fill();
      }
    }

    let raindrops = [];
    function initRain() {
      raindrops = Array.from({length:200},()=>({ x: rand(0,W), y: rand(0,H), len: rand(10,20), speed: rand(4,8) }));
    }
    function drawRain() {
      ctx.strokeStyle='rgba(200,200,255,0.5)'; ctx.lineWidth=1;
      raindrops.forEach(r=>{
        ctx.beginPath(); ctx.moveTo(r.x,r.y); ctx.lineTo(r.x,r.y+r.len); ctx.stroke();
        r.y += r.speed;
        if (r.y>H) r.y = -r.len;
      });
    }

    function drawClouds() {
      ctx.fillStyle='rgba(255,255,255,0.7)';
      for (let i=0;i<5;i++) {
        const cx = (i*200 + (Date.now()*0.02)%W) % W;
        ctx.beginPath();
        ctx.arc(cx, H*0.2, 50,0,2*Math.PI);
        ctx.arc(cx+60, H*0.2+10,40,0,2*Math.PI);
        ctx.arc(cx+30, H*0.2+20,45,0,2*Math.PI);
        ctx.fill();
      }
    }

    // Slow loop (~10fps)
    setInterval(()=>{
      const t = Date.now();
      drawSky(t);
      drawHills(t);
      if (weatherStates[weatherIndex]==='cloudy') drawClouds();
      if (weatherStates[weatherIndex]==='rainy') drawRain();
      for (let i=0;i<8;i++) {
        const px = (i/8)*W + rand(-80,80);
        drawTree(px, H*0.85, 70, -Math.PI/2, 5);
      }
    }, 100);

    // Initialize rain when needed
    setInterval(()=>{
      if (weatherStates[weatherIndex]==='rainy') initRain();
    }, 1000);

  </script>
</body>
</html>
