<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paisaje Generativo Vivo</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>

  <script>
    // Setup canvas
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    let W, H;
    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Utility: random range
    function rand(min, max) { return Math.random() * (max - min) + min; }

    // Perlin noise (simple implementation)
    class Noise {
      constructor() { this.perm = []; for (let i=0; i<512; i++) this.perm[i] = Math.floor(Math.random()*256);
      }
      grad(hash, x) { return (hash & 1) ? -x : x; }
      fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
      lerp(t, a, b) { return a + t * (b - a); }
      get(x) {
        let xi = Math.floor(x) & 255;
        let xf = x - Math.floor(x);
        let u = this.fade(xf);
        let a = this.perm[xi], b = this.perm[xi+1];
        return this.lerp(u, this.grad(a, xf), this.grad(b, xf-1)) * 2;
      }
    }
    const noise = new Noise();

    // Sky gradient
    function drawSky(t) {
      const grd = ctx.createLinearGradient(0, 0, 0, H);
      const a = (Math.sin(t*0.1)+1)/2;
      // day to sunset
      grd.addColorStop(0, `rgba(${135 + 120*a|0}, ${206 - 100*a|0}, ${235 - 200*a|0}, 1)`);
      grd.addColorStop(1, `rgba(${220 + 35*a|0}, ${246 - 50*a|0}, ${255 - 255*a|0}, 1)`);
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, W, H);
    }

    // Draw hills
    function drawHills(t) {
      for (let layer = 0; layer < 3; layer++) {
        ctx.beginPath();
        const yBase = H * (0.5 + layer*0.15);
        ctx.moveTo(0, H);
        for (let x=0; x<=W; x+=10) {
          const y = yBase + noise.get(x*0.005 + t*0.0005 + layer*10) * 50;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(W, H);
        ctx.closePath();
        ctx.fillStyle = `rgba(30, ${80 + layer*40}, 30, ${0.4 - layer*0.1})`;
        ctx.fill();
      }
    }

    // Recursive tree
    function drawTree(x, y, len, angle, depth) {
      if (depth === 0) return;
      const x2 = x + Math.cos(angle) * len;
      const y2 = y + Math.sin(angle) * len;
      ctx.strokeStyle = `rgb(${50 + depth*20}, ${30 + depth*10}, 20)`;
      ctx.lineWidth = depth;
      ctx.beginPath(); ctx.moveTo(x, y);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      const sway = Math.sin(Date.now() * 0.002 + depth) * 0.1;
      drawTree(x2, y2, len * 0.7, angle - 0.5 + sway, depth - 1);
      drawTree(x2, y2, len * 0.7, angle + 0.5 + sway, depth - 1);
      if (depth < 3) {
        ctx.fillStyle = 'rgba(34,139,34,0.6)';
        ctx.beginPath();
        ctx.arc(x2, y2, depth*3, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // Birds
    const birds = Array.from({length: 10}, () => ({
      x: rand(0, W), y: rand(0, H*0.3), speed: rand(0.5, 2)
    }));
    function drawBirds() {
      ctx.fillStyle = '#333';
      birds.forEach(b => {
        const size = 5;
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x + size, b.y + size/2);
        ctx.lineTo(b.x, b.y + size);
        ctx.fill();
        b.x += b.speed;
        if (b.x > W + 20) b.x = -20;
      });
    }

    // Main loop
    function animate() {
      const t = Date.now();
      drawSky(t);
      drawHills(t);
      // draw a few trees
      for (let i=0; i<10; i++) {
        const px = (i/10) * W + rand(-50,50);
        drawTree(px, H*0.8, 80, -Math.PI/2, 5);
      }
      drawBirds();
      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
